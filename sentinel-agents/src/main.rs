// src/main.rs
// ==============================================================================
// OMEGA PLATFORM - SENTINEL AGENT (RUST COMPONENT)
// ==============================================================================
//
// This file contains the Rust implementation for the Sentinel Agent. It is
// compiled as a static library and exposes a C-compatible FFI for use by the
// C orchestrator (`main.c`).
//
// Responsibilities:
// - Manages a `tokio` async runtime for high-performance, non-blocking I/O.
// - Establishes and maintains a secure gRPC client connection to the Mesh Network.
// - Handles serialization/deserialization of telemetry data.
// - Provides a safe FFI boundary for the C component to call into Rust.
//

#![crate_type = "staticlib"]

use std::ffi::{CStr, CString};
use std::os::raw::c_char;
use std::sync::Once;
use std::thread;

use serde::{Deserialize, Serialize};
use tokio::runtime::{Builder, Runtime};
use tokio::sync::{mpsc, OnceCell};
use tonic::transport::{Channel, Endpoint};
use tracing::{error, info, instrument, warn};
use tracing_subscriber::{fmt, EnvFilter};

// Assuming gRPC code is generated from .proto files into this module
mod proto {
    // In a real build, this would be generated by tonic-build
    // For this example, we manually define a placeholder.
    pub mod mesh_service {
        use tonic::codegen::*;

        #[derive(Debug, Clone, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct TelemetryData {
            pub timestamp: i64,
            pub source: String,
            pub r#type: String,
            pub payload: serde_json::Value,
        }

        #[derive(Debug, Clone)]
        pub struct MeshServiceClient<T> { inner: T }
        impl<T> MeshServiceClient<T> {
            pub fn new(inner: T) -> Self { Self { inner } }
        }
    }
}

use proto::mesh_service::{MeshServiceClient, TelemetryData};

// --- Global State Management for FFI ---
// Use OnceCell to safely initialize and access global state across FFI calls.
static TOKIO_RUNTIME: OnceCell<Runtime> = OnceCell::const_new();
static GRPC_CLIENT: OnceCell<MeshServiceClient<Channel>> = OnceCell::const_new();
static SHUTDOWN_SENDER: OnceCell<mpsc::Sender<()>> = OnceCell::const_new();

// --- Initialization & Setup ---
static INIT: Once = Once::new();

#[no_mangle]
pub extern "C" fn rust_component_init() {
    INIT.call_once(|| {
        // Setup tracing logger
        fmt()
            .with_env_filter(EnvFilter::from_default_env().add_directive("info".parse().unwrap()))
            .with_target(true)
            .init();
        info!("[Rust] Component initialized.");
    });
}

#[no_mangle]
pub extern "C" fn rust_start_grpc_client() {
    info!("[Rust] Starting Tokio runtime and gRPC client in a background thread.");

    let (shutdown_tx, mut shutdown_rx) = mpsc::channel(1);
    SHUTDOWN_SENDER.set(shutdown_tx).expect("Failed to set shutdown sender");

    thread::spawn(move || {
        let runtime = Builder::new_multi_thread()
            .enable_all()
            .build()
            .expect("Failed to build Tokio runtime");

        TOKIO_RUNTIME.set(runtime).expect("Failed to set Tokio runtime");
        
        let runtime_handle = TOKIO_RUNTIME.get().unwrap();
        runtime_handle.block_on(async move {
            info!("[Rust] Tokio runtime started.");
            
            // Connect to Mesh Network gRPC server
            let client = match connect_to_mesh("http://[::1]:50051").await { // Example address
                Ok(c) => c,
                Err(e) => {
                    error!("[Rust] Failed to connect to gRPC server: {}", e);
                    return;
                }
            };
            GRPC_CLIENT.set(client).expect("Failed to set gRPC client");
            info!("[Rust] gRPC client connected to Mesh Network.");

            // Keep the runtime alive until a shutdown signal is received
            shutdown_rx.recv().await;
            info!("[Rust] Shutdown signal received, terminating runtime.");
        });
    });
    
    // Give the thread a moment to initialize
    thread::sleep(std::time::Duration::from_millis(100));
}

async fn connect_to_mesh(address: &'static str) -> Result<MeshServiceClient<Channel>, tonic::transport::Error> {
    let endpoint = Endpoint::from_static(address);
    // TODO: Configure PQC-hardened TLS here using `oqs` and `rustls`
    let channel = endpoint.connect().await?;
    Ok(MeshServiceClient::new(channel))
}

// --- FFI Function for Sending Telemetry ---
#[no_mangle]
#[instrument(skip(telemetry_json), fields(json_len = telemetry_json.as_ref().map(|s| s.len()).unwrap_or(0)))]
pub extern "C" fn rust_send_telemetry(telemetry_json: *const c_char) {
    if telemetry_json.is_null() {
        error!("[Rust FFI] Received null pointer for telemetry_json.");
        return;
    }

    let c_str = unsafe { CStr::from_ptr(telemetry_json) };
    let json_str = match c_str.to_str() {
        Ok(s) => s,
        Err(e) => {
            error!("[Rust FFI] Failed to convert C string to Rust string: {}", e);
            return;
        }
    };

    let telemetry_data: TelemetryData = match serde_json::from_str(json_str) {
        Ok(data) => data,
        Err(e) => {
            error!("[Rust FFI] Failed to deserialize telemetry JSON: {}", e);
            return;
        }
    };

    info!("[Rust FFI] Received telemetry to send: type='{}'", telemetry_data.r#type);

    // Get a handle to the runtime and gRPC client
    let runtime = match TOKIO_RUNTIME.get() {
        Some(rt) => rt,
        None => {
            error!("[Rust FFI] Tokio runtime not initialized.");
            return;
        }
    };
    
    // In a real implementation, you would use a channel to send data to a dedicated
    // gRPC task instead of cloning the client every time. For this example, we spawn
    // a new task for each FFI call.
    runtime.spawn(async move {
        // This is a placeholder for the actual gRPC call.
        // let mut client = match GRPC_CLIENT.get() {
        //     Some(c) => c.clone(),
        //     None => {
        //         error!("[Rust Task] gRPC client not available.");
        //         return;
        //     }
        // };
        // let request = tonic::Request::new(telemetry_data);
        // if let Err(e) = client.send_telemetry(request).await {
        //     error!("[Rust Task] Failed to send telemetry via gRPC: {}", e);
        // } else {
        //     info!("[Rust Task] Telemetry successfully sent.");
        // }
        
        // Simulate async work
        tokio::time::sleep(std::time::Duration::from_millis(50)).await;
        info!("[Rust Task] Telemetry for type '{}' processed.", telemetry_data.r#type);
    });
}

// --- FFI Function for Shutdown ---
#[no_mangle]
pub extern "C" fn rust_component_shutdown() {
    info!("[Rust FFI] Initiating shutdown of Rust component.");

    if let Some(sender) = SHUTDOWN_SENDER.get() {
        // Send the shutdown signal. Use `blocking_send` as we are in a synchronous FFI context.
        if let Err(e) = sender.blocking_send(()) {
            error!("[Rust FFI] Failed to send shutdown signal: {}", e);
        }
    } else {
        warn!("[Rust FFI] Shutdown called, but component was not running.");
    }

    // In a real application, you might want to join the thread here,
    // but that could block the C caller for a long time.
    // The current design lets the runtime shut down in the background.
    info!("[Rust FFI] Shutdown signal sent. Runtime will terminate asynchronously.");
}

// --- Empty main function ---
// This is a static library, so `main` is not the entry point.
// However, a `main` function is still required by some linkers.
fn main() {}